<!DOCTYPE html>
<html class="no-js" lang="">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />

    <title>Page Specific Javascript with Phoenix LiveView and Esbuild</title>
    <meta name="description" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link
      rel="stylesheet"
      href="./styles/output.css"
      type="text/css"
      media="screen"
    />
  </head>
  <body>
    <header class="flex items-center justify-between">
      <p><a href="/">back to home</a></p>
      <p>2022-04-21</p>
    </header>
    <article>
      <h1>Page Specific Javascript with Phoenix LiveView and Esbuild</h1>
      <p>
        Even though LiveView has a minimal Javascript footprint, custom JS code
        for complex production apps can increase the size of the
        <code> app.js </code> file since all javascript, including modules are
        imported in the same file. This file is also included on every page
        which leads uneccasary code being downloaded and executed.
      </p>
      <p>
        I faced this issue when I was building IndiePaper. The editor page
        required a lot of heavy packages, since I relied on Hooks there was no
        way than to bundle everything up into the main file. This made
        <code>app.js</code> around 1.4MB of Javascript which was included on all
        pages. This post explains how to split the file and import the required
        code, page wise.
      </p>
      <section>
        <h2>Code Splitting and Dynamic Imports</h2>
        <p>
          Phoenix uses Esbuild to bundle assets. Bundling is the process of
          taking code in separate modules and combining it into a single file,
          minifying and converting to standard javascript in the process. This
          is why your <code>app.js</code> increases in size when you import more
          files. We can reduce the size by splitting the files based on the
          pages that require it and dynamically load the required parts when
          needed.
        </p>
        <p>
          Rather than bundle everything into a single file, we instruct
          <code>esbuild</code> to bundle every page as a separate chunk. When we
          call the relevant Hook, the file gets automatically fetched and
          executed.
        </p>

        <h3>Starting point</h3>
        <p>
          Consider that we have a LiveView app with two pages. One page is an
          online text editor hence is Javascript heavy. Initially we are going
          to have all the code be in the <code> app.js </code> file.
        </p>
        <pre>
import { Editor } from "@tiptap/core";
import StarterKit from "@tiptap/starter-kit";

...

let Hooks = {};
Hooks.SimpleTipTapHtmlEditor = {
  mounted() {
    const contentHTMLElementId = this.el.dataset.contentHtmlElementId;
    const editorElementId = this.el.dataset.editorElementId;

    window.tipTapHtmlEditor = new Editor({
      element: editorElement,
      content: contentHTMLElement.value,
    };
};

let liveSocket = new LiveSocket(socketHost, Socket, {
  params: { _csrf_token: csrfToken },
  hooks: Hooks});
        </pre>
        <p>
          This increases the size of the file. Even though the code is only
          required in the editor page, it is downloaded on every page.
        </p>

        <h3>Refactor to Modules</h3>
        <p>
          First step is to extract the code for the editor to a new function,
          export it from a new file <code> simple-editor.js </code> and include
          that in <code>app.js</code>.
        </p>
        <pre>
# simple-editor.js
import { Editor } from "@tiptap/core";
import StarterKit from "@tiptap/starter-kit";

export function setupSimpleTipTapHtmlEditor(
  contentHTMLElementId,
  editorElementId
) {
  const contentHTMLElement = document.getElementById(contentHTMLElementId);
  const editorElement = document.getElementById(editorElementId);

  window.tipTapHtmlEditor = new Editor({
    element: editorElement,
    content: contentHTMLElement.value,
  });
}
        </pre>
        <h3>Setup Dynamic Import</h3>
        <p>
          Import that file in <code> app.js </code> and replace with the hook
          with the dynamic function call, and remove the old imports from the
          top.
        </p>
        <pre>
# app.js
let Hooks = {};
Hooks.SimpleTipTapHtmlEditor = {
  mounted() {
    const contentHTMLElementId = this.el.dataset.contentHtmlElementId;
    const editorElementId = this.el.dataset.editorElementId;

    import("./simple-editor").then(
      ({ setupSimpleTipTapHtmlEditor }) => {
        setupSimpleTipTapHtmlEditor(contentHTMLElementId, editorElementId);
      }
    );
  },
};
        </pre>
        <p>
          The <code> import </code> statement has a different promise based form
          here. When the import is encountered, the chunk of code is fetched
          dynamically and then executed. We need to enable
        </p>

        <h3>Setup Esbuild Chunking</h3>
        <p>
          When we enable Esbuild chunks, rather than bundling everything
          together, Esbuild creates different <code> chunk </code> files.
          Esbuild in Phoenix is configured with editing
          <code> config/config.exs </code>
        </p>
        <pre>
#config.exs
...

# Configure esbuild (the version is required)
config :esbuild,
  version: "0.14.0",
  default: [
    args: ~w(js/app.js js/simple-editor.js
        --chunk-names=chunks/[name]-[hash] --splitting --format=esm --bundle --target=es2017 --minify
        --outdir=../priv/static/assets --external:/fonts/* --external:/images/*),
    cd: Path.expand("../assets", __DIR__),
    env: %{"NODE_PATH" => Path.expand("../deps", __DIR__)}
  ]

        </pre>
        <p>
          We have added the file <code> js/simple-editor.js </code> to list of
          files, and added a set of options to enable splitting.
        </p>
        <pre>
--chunk-names=chunks/[name]-[hash] --splitting --format=esm --bundle --target=es2017 --minify
        </pre>
        <h3>Import as module</h3>
        <p>
          Finally you have to set the import of <code> app.js </code> in your
          <code> root.html.heex </code> as module.
        </p>
        <pre>
&lt;script type=&quot;module&quot; defer phx-track-static type=&quot;text/javascript&quot; src={Routes.static_path(@conn, &quot;/assets/app.js&quot;)}&gt;&lt;/script&gt;
        </pre>
      </section>
      <section>
        <h2>Conclusion</h2>
      </section>
      <section>
        <h2>Extra bits</h2>
      </section>
    </article>
  </body>
</html>
